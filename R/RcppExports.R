# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Solve XA=B for two matrices A and B.
#'
#' Eigen does not have builtin methods to solve XA=B, only AX=B, so we 
#' solve A'X'= B'
#'
#' @param A
#' @param B
#' @return X matrix
NULL

#' Compute Hamiltonian dynamics after specified time.
#'
#' @param position starting position
#' @param momentum starting momentum
#' @param time amount of time the system is run for
#' @return pair of new (position, momentum)
NULL

#' Reflect momentum off of a constraint boundary.
#' 
#' Given a constraint boundary, calculate the momentum as if that boundary 
#' was a wall and there is an elastic collision, and the angle of incidence 
#' equals the angle of reflection.
#'
#' @param momentum starting momentum
#' @param constraint_direc F matrix (k-by-d matrix where k is the number of 
#' linear constraints)
#' @param constraint_row_normsq vector of squared row norms ofr constraint_direc
#' @param bounce_idx integer index of which constraint is being bounced off of
#' @param time amount of time the system is run for
#' @return momentum after bouncing
NULL

#' Compute when the next bounce occurs and which constraint it occurs on.
#'
#' @param position starting position
#' @param momentum starting momentum
#' @param constraint_direc F matrix (k-by-d matrix where k is the number of 
#' linear constraints)
#' @param constraint_bound g vector (k dimensional)
#' @return pair of new (time until bounce, constraint index corresponding to bounce)
NULL

#' Whiten a given position into the standard normal frame.
#'
#' @param position starting position
#' @param momentum starting momentum
#' @param constraint_direc F matrix (k-by-d matrix where k is the number of 
#' linear constraints)
#' @param constraint_bound g vector (k dimensional)
#' @param cholesky_factor upper triangular matrix R from cholesky decomposition of 
#' precision or covariance matrix into R^TR
#' @param mean mean of unconstrained Gaussian
#' @param prec_parametrized boolean for whether parametrization is by precision (true) 
#' or covariance matrix (false)
#' @return vector of position in standard normal frame
NULL

#' Convert a position from standard normal frame back to original frame.
#'
#' @param position starting position
#' @param cholesky_factor upper triangular matrix R from cholesky decomposition of 
#' precision or covariance matrix into R^TR
#' @param mean mean of unconstrained Gaussian 
#' @param prec_parametrized boolean for whether parametrization is by precision (true) 
#' or covariance matrix (false)
#' @return vector of position in original frame
NULL

#' Generate a sample from a truncated standard normal distribution
#'
#' @param initial_position starting position
#' @param initial_momentum starting momentum
#' @param constraint_direc F matrix (k-by-d matrix where k is the number of 
#' linear constraints)
#' @param constraint_row_normsq vector of squared row norms ofr constraint_direc
#' @param constraint_bound g vector (k dimensional)
#' @param total_time total time the particle will bounce for
#' @return vector of position in standard normal frame
NULL

#' Compute Cholesky decomposition of a matrix.
#'
#' @param A matrix to decompose
#' @return upper triangular matrix R such that A = R'R.
Cholesky <- function(A) {
    .Call(`_hzz_Cholesky`, A)
}

#' Whiten constraints for use in GenerateUnwhitenedSample
#'
#' Transforms constraints of the form Fx+g >= 0 for a target normal distribution
#' into the corresponding constraints for a standard normal.
#'
#' @param constraint_direc F matrix (k-by-d matrix where k is the number of 
#' linear constraints)
#' @param constraint_bound g vector (k dimensional)
#' @param cholesky_factor upper triangular matrix R from cholesky decomposition of 
#' precision or covariance matrix into R^TR
#' @param mean mean of unconstrained Gaussian
#' @param prec_parametrized boolean for whether parametrization is by precision (true) 
#' or covariance matrix (false)
#' @return List of new constraint directions, the squared row norms of those 
#' constraints (for computational efficiency later), and new bounds
WhitenConstraints <- function(constraint_direc, constraint_bound, cholesky_factor, mean, prec_parametrized) {
    .Call(`_hzz_WhitenConstraints`, constraint_direc, constraint_bound, cholesky_factor, mean, prec_parametrized)
}

#' Generate a sample from a truncated normal distribution.
#' 
#' First "whiten" the constraints and starting position into the standard normal
#' frame, then generate a sample in that frame, and the convert back to the original
#' frame.
#'
#' @param initial_position starting position
#' @param initial_momentum starting momentum
#' @param constraint_direc F matrix (k-by-d matrix where k is the number of 
#' linear constraints)
#' @param constraint_row_normsq vector of squared row norms ofr constraint_direc
#' @param constraint_bound g vector (k dimensional)
#' @param cholesky_factor upper triangular matrix R from cholesky decomposition of 
#' precision or covariance matrix into R^TR
#' @param mean mean of unconstrained Gaussian
#' @param total_time total time the particle will bounce for
#' @param prec_parametrized boolean for whether parametrization is by precision (true) 
#' or covariance matrix (false)
#' @return vector of position in standard normal frame
GenerateSample <- function(initial_position, initial_momentum, constraint_direc, constraint_row_normsq, constraint_bound, cholesky_factor, mean, total_time, prec_parametrized) {
    .Call(`_hzz_GenerateSample`, initial_position, initial_momentum, constraint_direc, constraint_row_normsq, constraint_bound, cholesky_factor, mean, total_time, prec_parametrized)
}

#' @export
rcpp_hello_world <- function() {
    .Call(`_hzz_rcpp_hello_world`)
}

#' Create ZigZag engine object
#'
#' Helper function creates zigZag engine object with given latent dimension, location count and various
#' implementation details. Called by \code{MassivezigZag::engineInitial()}.
#'
#' @param locationCount Number of locations and size of distance matrix.
#' @param tbb Number of CPU cores to be used.
#' @param simd For CPU implementation: no SIMD (\code{0}), SSE (\code{1}) or AVX (\code{2}).
#' @param truncation Likelihood includes truncation term? Defaults to \code{TRUE}.
#' @param gpu Which GPU to use? If only 1 available, use \code{gpu=1}. Defaults to \code{0}, no GPU.
#' @param single Set \code{single=1} if your GPU does not accommodate doubles.
#' @return zigZag engine object.
#'
#' @export
createEngine <- function(dimension, mask, observed, parameterSign, flags, info, seed) {
    .Call(`_hzz_createEngine`, dimension, mask, observed, parameterSign, flags, info, seed)
}

createNutsEngine <- function(dimension, mask, observed, parameterSign, flags, info, seed, randomFlg, stepSize, mean, precision) {
    .Call(`_hzz_createNutsEngine`, dimension, mask, observed, parameterSign, flags, info, seed, randomFlg, stepSize, mean, precision)
}

setMean <- function(sexp, mean) {
    invisible(.Call(`_hzz_setMean`, sexp, mean))
}

setPrecision <- function(sexp, precision) {
    invisible(.Call(`_hzz_setPrecision`, sexp, precision))
}

.doSomething <- function(sexp, data) {
    invisible(.Call(`_hzz_doSomething`, sexp, data))
}

getNextEvent <- function(sexp, position, velocity, action, logpdfGradient, momentum) {
    .Call(`_hzz_getNextEvent`, sexp, position, velocity, action, logpdfGradient, momentum)
}

.oneIteration <- function(sexp, position, momentum, time) {
    .Call(`_hzz_oneIteration`, sexp, position, momentum, time)
}

.oneNutsIteration <- function(sexp, position, momentum, stepsize) {
    .Call(`_hzz_oneNutsIteration`, sexp, position, momentum, stepsize)
}

